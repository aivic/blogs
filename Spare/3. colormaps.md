## Introduction
No one can deny the fact that the React components are arguably the best when it comes to rendering to arrive on some desired results. It is not just because of the variety of the result options offered by the components but also because of their customizable flexibility.

The props are quite resilient in React. In most of the situations demonstrated by the React Component, it is the child component which merely put in the use of props passed on by parent component. Nevertheless, there are cases in which the user would like to outspread the incoming props with the help of some relatively new data prior to the rendering of child component. The user with the general knowledge of the React can well understand the role of CSS classes and update styles. In React, one can find an add-on which can enable the cloning of a component as well as ranging its props simultaneously. This add-on is generally termed as `cloneWithProps`.

Although the add-on works in general sense, but, if in case, it is not working properly as per the requirement of the coder then one does not need to be disappointed at all. In case, if the add-on is not fully functional with React then the React can implement top notch Application Programming Interface (API). If there is a problem with the refs of child component and unable to avail access to lately cloned child components, then the API method `React.cloneElement` can help us with the cloning as well as extending of a component. Here, the best part is that the Application Programming Interface used here is quite genuine and easy to execute. 

## Cloning a React Component with React.JS rather than jQuery.js
Here, we will try to learn not only the cloning of a React Component but also to append it somewhere else. The requirement of the coder will be to work on some of the fieldsets with the application of React.JS + Backbone.JS. In order to make it work, there has to be a table containing having several rows and columns. The work will be to ensure that the first column is fixed at whatever time the total number of columns is larger than to be showcased on the screen. It can be properly understood by the following example. 

Let’s say that the total numbers of columns existing within the table are eight, but only six columns can be displayed on the big screen. Hence, the remaining two columns can be observed by scrolling in the horizontal direction. 

In the current logic, it is advisable to apply jQuery in order to clone each of the first columns with respect to each row. It will help in the creation of a new table. This new table can be appended after original table. In order to place it over the original table, one can use the CSS; hence it would be easier for the user to see the successfully fixed first column. 

The approach mentioned above can still witness improvement in the due course of time and it is needed to be executed with the help of great Document Object Model (DOM) of the great CSS ReactJS. 

The user can commence with a plain React Table component as mentioned below:


```javascript
var Table= React.createClass ({
    render: function() {
        return <table>
            { this.props.data.map( function ( row ) {
                return <tr>
                    { row.map( function ( cell ) {
                        return <td > { cell } </ td>
                    })}
                </ tr>
            })}
        </ table>;
    }
});
```

The components mentioned above are merely a demonstration; the actual table would be far more composite or complex. 

Now, the following will be the table that the user could wish to have is this component:


```javascript
var DubbledTable= React.createClass ({
    render: function() {
        var firstColumn = 
            this.props.data.map( function ( row ) {
                return [row[0]]
            })
        return <span >
            <Table data = { firstColumn } />
            <Table data = { this.props.data } />
        </ span>
    }
})
```

## Cloning of the React.JS Elements with React.cloneElement Rather than cloneWithProps

In some of the exceptional situations, the user may wish to generate the clone of a React component with the aid of various props that were associated with the original component. For instance, it can be understood by the cloning of the React components by accessing into the `this.props.children` and then rendering them via various props. 


```javascript
var cloneWithProps = require('react-addons-clone-with-props');

var _makeBlue = function(element) {
  return cloneWithProps(element, { style: { color: 'blue' }});
};

var Blue = React.createClass({
  render: function() {
    var blueChildren = React.Children.map(this.props.children, _makeBlue);
    return <div >{ blueChildren }</ div>;
  }
});

ReactDOM.render(
  <Blue >
    <p >This text is blue.</ p>
  </ Blue>,
  document.getElementById('container')
);
```

Here, cloneWithProps will not transfer the key or ref into the cloned component. The styleprops as well as className are automatically merged.


## Conclusion 
As one can find with the above code, in the selective situations an element would like to modify the props of another element which it doesn’t own one way or the other. Likewise, modifying the `className` of an element passed in the form of `this.props.children`. In other conditions, it would like to make a number of copies of an element passed via it. It is feasible with `cloneWithProps()`. 

ReactComponent React.addons.cloneWithProps(ReactComponent component, object? extraProps)

The common question that arises here is, do a shallow copy of an element and merge any props delivered by extraProps? The Props are combined in an identical manner as transferPropsTo(), hence the props such as className will be combined in a wise manner.

## Note
The `cloneWithProps` usually does not relocate the key prop to a cloned element. If as a user, you have an objective to safeguard the key, then the best thing you can do is to include it to the `extraProps` object. 

The command associated with the measure will be the following: 


```
js var clonedComponent = cloneWithProps(originalComponent, { key : originalComponent.props.key });ref is another prop that is not preserved either.
```

It is advisable that the user tries and finds out how the end results fetch out to him or her. It is true that the coding of the cloning component mentioned above is open for correction and introduction of new techniques which can fetch even better results. But till now, it is the best technique that one could avail online and make stable copies of the components on CSS React platform. 
